## Overview算法笔记

## 1.Derivation

+ people
+ animal
+ transportation
+ natural pheonomena

## 2.Peoprocessing

### 2.1 noise filtering

#### 	Mean(Median) filter

> use n-1 predecessors to calculate the mean/median. 

> good for individual, need big window size for consecutive noise points.

> can result in bigger error.

#### 	Kalman and Particle filters  (53号论文)

> Kalman use speed. Assume linear model+ Gaussian noise.
>
> Particle: step1: generate P points from the initial distribution; 
>
> ​               step2: importance sampling.
>
> ​			    step3: importance weight.
>
> ​                step4: selection
>
> ​				step5:weight sum = $\sum_{i=1}^{P}\omega_i^{(j)}\hat x^j$

#### 	Heuristic based outlier detection

points with speed larger than threshold are removed.

### 2.2 stay point detection

dist threshold/ time span threshold.

从第一个点开始，不断加入点直到他们的距离超过阈值，形成一个簇。从不在簇中的点开始继续detect。（论文中还用timespan来测一下，一个簇的anchor point和最后一个点时间长度是否大于阈值）。

改进版本：一个簇形成之后，从簇中第二个点继续跑算法。相当于sliding size减小到1。

### 2.3 compression 

+ 两种measure error的方式。 1.perpendicular euclidean distance，2. time synchronized euclidean distance. 
+ 后者assume 匀速直线运动

**Douglas Peucker：**

找到error最大的点，分开，两边继续。从N^2提升到了NlogN



**Online：**

sliding window. keep adding points until error exceed some bound. reserve it and continue

open window:  keep adding…. find the max error point as the new anchor point.

[84]. new data point important or not.



**semantic meaning**

[17] Chen proposed TS.  firstly divide it into walking/non-walking segments. point weight：转向+邻居距离。

另一些：drop所有anchor point直到现在位置的中间点，只要follow shortest path。需要 map-matching

PRESS时空分别压缩。 空间压缩用short code来代表常用的路段。



### 2.4 Traj segmentation

+ time interval

time interval>threshold : split 

+ shape of traj

 turing points(head of direction turned over a threshold)

Douglus Peucker.

MDL: [51]   L(H),  L(D|H)

+ semantic meaning

**stay points. **

if estimate velocity, remove stay points.

if wanna compare similarity between users, only use the stay points.

**transportation modes**

walk vs non-walk.



### 2.5 MapMatching

- additional information used

  + geometric: shape of indiv link.
  + topological algorithms: 
    + connectivity of road network
    + Frechet distance (dist between GPS sequence & candidate road sequence)
  + probablistic alg:
    
  + deal with noisy, low sampling rate trajs
    
  + advanced.

    

- range of sampling points

  + local  通常 online
  + global offline. entire trajs - road networks

  



【54】算法： 对某个点p，画个圆，圆内的segment都是candidite，然后投影到每个segment上，生成ci，每个ci都是candidate point，用高斯分布计算概率。然后同时进行概率传递，传递的概率是两个ci的euclidean dist除以路网dist。

local+transition确定最好的点。



## 3. Data management



### Indexing and retrieval



#### > 3 approaches of range queries.

+ time as the third cood.  3D Rtree , 3D Query box.  

  + good for recent hours, bad for long time span. overlaps.  
  + <span style="color:red">不是特别清楚frequently update index</span>
  + can be improved, but not perfect anyway.

+ Rtree index for each interval（time slot）

  + query来了就找time slot，找到了再找spatial info

+ 先通过spatial 分成gird。 对每个grid里的数据建立时间索引。

  + CSE tree 。
  + 每个segment都有一个2d index （startTime，endTime），这些point被b+ tree存起来。
  + 查询时，先找所有相关grid，然后再去b+tree 找到segments，最后merge这些segments的ID以及始末时间。

  

#### > KNN Queries.

+ point query
  + order may matter
  + 更加在乎traj是否跟query点的连接性更好，而不是shape
+ traj query
  + 相似度
  + 要retrieve 车子在某条路上的轨迹
    + 把路网看作traj，算相似度
    + 把query traj 分开成segments，然后用mma去匹配road。
    + road & traj relationship stored in a suffix tree-like index。
      + 每个node是road segment，每个edge代表path。
      + 每个node都存着我这个road segment都有哪些traj走过 $T_{r_i}$，走了多久 $t_{r_i}$。
      + 很显然适合recent，因为每加一个traj，就得加很多index

### Distance & Similarities of Trajectories



